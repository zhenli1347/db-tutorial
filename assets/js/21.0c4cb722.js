(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{355:function(t,s,a){"use strict";a.r(s);var r=a(4),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"mysql-性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql-性能优化"}},[t._v("#")]),t._v(" Mysql 性能优化")]),t._v(" "),s("h2",{attrs:{id:"_1-数据结构优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据结构优化"}},[t._v("#")]),t._v(" 1. 数据结构优化")]),t._v(" "),s("p",[t._v("良好的逻辑设计和物理设计是高性能的基石。")]),t._v(" "),s("h3",{attrs:{id:"_1-1-数据类型优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-数据类型优化"}},[t._v("#")]),t._v(" 1.1. 数据类型优化")]),t._v(" "),s("h4",{attrs:{id:"数据类型优化基本原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据类型优化基本原则"}},[t._v("#")]),t._v(" 数据类型优化基本原则")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("更小的通常更好")]),t._v(" - 越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的 CPU 周期也更少。\n"),s("ul",[s("li",[t._v("例如：整型比字符类型操作代价低，因而会使用整型来存储 IP 地址，使用 "),s("code",[t._v("DATETIME")]),t._v(" 来存储时间，而不是使用字符串。")])])]),t._v(" "),s("li",[s("strong",[t._v("简单就好")]),t._v(" - 如整型比字符型操作代价低。\n"),s("ul",[s("li",[t._v("例如：很多软件会用整型来存储 IP 地址。")]),t._v(" "),s("li",[t._v("例如："),s("strong",[s("code",[t._v("UNSIGNED")]),t._v(" 表示不允许负值，大致可以使正数的上限提高一倍")]),t._v("。")])])]),t._v(" "),s("li",[s("strong",[t._v("尽量避免 NULL")]),t._v(" - 可为 NULL 的列会使得索引、索引统计和值比较都更复杂。")])]),t._v(" "),s("h4",{attrs:{id:"类型的选择"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类型的选择"}},[t._v("#")]),t._v(" 类型的选择")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("整数类型通常是标识列最好的选择，因为它们很快并且可以使用 "),s("code",[t._v("AUTO_INCREMENT")]),t._v("。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("ENUM")]),t._v(" 和 "),s("code",[t._v("SET")]),t._v(" 类型通常是一个糟糕的选择，应尽量避免。")])]),t._v(" "),s("li",[s("p",[t._v("应该尽量避免用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。对于 "),s("code",[t._v("MD5")]),t._v("、"),s("code",[t._v("SHA")]),t._v("、"),s("code",[t._v("UUID")]),t._v(" 这类随机字符串，由于比较随机，所以可能分布在很大的空间内，导致 "),s("code",[t._v("INSERT")]),t._v(" 以及一些 "),s("code",[t._v("SELECT")]),t._v(" 语句变得很慢。")]),t._v(" "),s("ul",[s("li",[t._v("如果存储 UUID ，应该移除 "),s("code",[t._v("-")]),t._v(" 符号；更好的做法是，用 "),s("code",[t._v("UNHEX()")]),t._v(" 函数转换 UUID 值为 16 字节的数字，并存储在一个 "),s("code",[t._v("BINARY(16)")]),t._v(" 的列中，检索时，可以通过 "),s("code",[t._v("HEX()")]),t._v(" 函数来格式化为 16 进制格式。")])])])]),t._v(" "),s("h3",{attrs:{id:"_1-2-表设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-表设计"}},[t._v("#")]),t._v(" 1.2. 表设计")]),t._v(" "),s("p",[t._v("应该避免的设计问题：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("太多的列")]),t._v(" - 设计者为了图方便，将大量冗余列加入表中，实际查询中，表中很多列是用不到的。这种宽表模式设计，会造成不小的性能代价，尤其是 "),s("code",[t._v("ALTER TABLE")]),t._v(" 非常耗时。")]),t._v(" "),s("li",[s("strong",[t._v("太多的关联")]),t._v(" - 所谓的实体 - 属性 - 值（EVA）设计模式是一个常见的糟糕设计模式。Mysql 限制了每个关联操作最多只能有 61 张表，但 EVA 模式需要许多自关联。")]),t._v(" "),s("li",[s("strong",[t._v("枚举")]),t._v(" - 尽量不要用枚举，因为添加和删除字符串（枚举选项）必须使用 "),s("code",[t._v("ALTER TABLE")]),t._v("。")]),t._v(" "),s("li",[t._v("尽量避免 "),s("code",[t._v("NULL")])])]),t._v(" "),s("h3",{attrs:{id:"_1-3-范式和反范式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-范式和反范式"}},[t._v("#")]),t._v(" 1.3. 范式和反范式")]),t._v(" "),s("p",[s("strong",[t._v("范式化目标是尽量减少冗余，而反范式化则相反")]),t._v("。")]),t._v(" "),s("p",[t._v("范式化的优点：")]),t._v(" "),s("ul",[s("li",[t._v("比反范式更节省空间")]),t._v(" "),s("li",[t._v("更新操作比反范式快")]),t._v(" "),s("li",[t._v("更少需要 "),s("code",[t._v("DISTINCT")]),t._v(" 或 "),s("code",[t._v("GROUP BY")]),t._v(" 语句")])]),t._v(" "),s("p",[t._v("范式化的缺点：")]),t._v(" "),s("ul",[s("li",[t._v("通常需要关联查询。而关联查询代价较高，如果是分表的关联查询，代价更是高昂。")])]),t._v(" "),s("p",[t._v("在真实世界中，很少会极端地使用范式化或反范式化。实际上，应该权衡范式和反范式的利弊，混合使用。")]),t._v(" "),s("h3",{attrs:{id:"_1-4-索引优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-索引优化"}},[t._v("#")]),t._v(" 1.4. 索引优化")]),t._v(" "),s("blockquote",[s("p",[t._v("索引优化应该是查询性能优化的最有效手段。")]),t._v(" "),s("p",[t._v("如果想详细了解索引特性请参考："),s("a",{attrs:{href:"https://github.com/dunwu/db-tutorial/blob/master/docs/sql/mysql/mysql-index.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Mysql 索引"),s("OutboundLink")],1)])]),t._v(" "),s("h4",{attrs:{id:"何时使用索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#何时使用索引"}},[t._v("#")]),t._v(" 何时使用索引")]),t._v(" "),s("ul",[s("li",[t._v("对于非常小的表，大部分情况下简单的全表扫描更高效。")]),t._v(" "),s("li",[t._v("对于中、大型表，索引非常有效。")]),t._v(" "),s("li",[t._v("对于特大型表，建立和使用索引的代价将随之增长。可以考虑使用分区技术。")]),t._v(" "),s("li",[t._v("如果表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。")])]),t._v(" "),s("h4",{attrs:{id:"索引优化策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引优化策略"}},[t._v("#")]),t._v(" 索引优化策略")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("索引基本原则")]),t._v(" "),s("ul",[s("li",[t._v("索引不是越多越好，不要为所有列都创建索引。")]),t._v(" "),s("li",[t._v("要尽量避免冗余和重复索引。")]),t._v(" "),s("li",[t._v("要考虑删除未使用的索引。")]),t._v(" "),s("li",[t._v("尽量的扩展索引，不要新建索引。")]),t._v(" "),s("li",[t._v("频繁作为 "),s("code",[t._v("WHERE")]),t._v(" 过滤条件的列应该考虑添加索引。")])])]),t._v(" "),s("li",[s("strong",[t._v("独立的列")]),t._v(" - “独立的列” 是指索引列不能是表达式的一部分，也不能是函数的参数。")]),t._v(" "),s("li",[s("strong",[t._v("前缀索引")]),t._v(" - 索引很长的字符列，可以索引开始的部分字符，这样可以大大节约索引空间。")]),t._v(" "),s("li",[s("strong",[t._v("最左匹配原则")]),t._v(" - 将选择性高的列或基数大的列优先排在多列索引最前列。")]),t._v(" "),s("li",[s("strong",[t._v("使用索引来排序")]),t._v(" - 索引最好既满足排序，又用于查找行。这样，就可以使用索引来对结果排序。")]),t._v(" "),s("li",[s("code",[t._v("=")]),t._v("、"),s("code",[t._v("IN")]),t._v(" 可以乱序 - 不需要考虑 "),s("code",[t._v("=")]),t._v("、"),s("code",[t._v("IN")]),t._v(" 等的顺序")]),t._v(" "),s("li",[s("strong",[t._v("覆盖索引")])]),t._v(" "),s("li",[s("strong",[t._v("自增字段作主键")])])]),t._v(" "),s("h2",{attrs:{id:"_2-sql-优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-sql-优化"}},[t._v("#")]),t._v(" 2. SQL 优化")]),t._v(" "),s("p",[t._v("使用 "),s("code",[t._v("EXPLAIN")]),t._v(" 命令查看当前 SQL 是否使用了索引，优化后，再通过执行计划（"),s("code",[t._v("EXPLAIN")]),t._v("）来查看优化效果。")]),t._v(" "),s("p",[t._v("SQL 优化基本思路：")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("只返回必要的列")]),t._v(" - 最好不要使用 "),s("code",[t._v("SELECT *")]),t._v(" 语句。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("只返回必要的行")]),t._v(" - 使用 "),s("code",[t._v("WHERE")]),t._v(" 子查询语句进行过滤查询，有时候也需要使用 "),s("code",[t._v("LIMIT")]),t._v(" 语句来限制返回的数据。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("缓存重复查询的数据")]),t._v(" - 应该考虑在客户端使用缓存，尽量不要使用 Mysql 服务器缓存（存在较多问题和限制）。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("使用索引来覆盖查询")])])])]),t._v(" "),s("h3",{attrs:{id:"_2-1-优化-count-查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-优化-count-查询"}},[t._v("#")]),t._v(" 2.1. 优化 "),s("code",[t._v("COUNT()")]),t._v(" 查询")]),t._v(" "),s("p",[s("code",[t._v("COUNT()")]),t._v(" 有两种作用：")]),t._v(" "),s("ul",[s("li",[t._v("统计某个列值的数量。统计列值时，要求列值是非 "),s("code",[t._v("NULL")]),t._v(" 的，它不会统计 "),s("code",[t._v("NULL")]),t._v("。")]),t._v(" "),s("li",[t._v("统计行数。")])]),t._v(" "),s("p",[s("strong",[t._v("统计列值时，要求列值是非空的，它不会统计 NULL")]),t._v("。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用 "),s("code",[t._v("COUNT(*)")]),t._v(" 时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计行数。")]),t._v(" "),s("p",[t._v("我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，如果要统计行数，直接使用 "),s("code",[t._v("COUNT(*)")]),t._v("，意义清晰，且性能更好。")]),t._v(" "),s("p",[t._v("（1）简单优化")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("count")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" world"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("city "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("count")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" world"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("city"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("count")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" world"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("city "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("（2）使用近似值")]),t._v(" "),s("p",[t._v("有时候某些业务场景并不需要完全精确的统计值，可以用近似值来代替，"),s("code",[t._v("EXPLAIN")]),t._v(" 出来的行数就是一个不错的近似值，而且执行 "),s("code",[t._v("EXPLAIN")]),t._v(" 并不需要真正地去执行查询，所以成本非常低。通常来说，执行 "),s("code",[t._v("COUNT()")]),t._v(" 都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL 层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如添加汇总表，或者使用 Redis 这样的外部缓存系统。")]),t._v(" "),s("h3",{attrs:{id:"_2-2-优化关联查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-优化关联查询"}},[t._v("#")]),t._v(" 2.2. 优化关联查询")]),t._v(" "),s("p",[t._v("在大数据场景下，表与表之间通过一个冗余字段来关联，要比直接使用 "),s("code",[t._v("JOIN")]),t._v(" 有更好的性能。")]),t._v(" "),s("p",[t._v("如果确实需要使用关联查询的情况下，需要特别注意的是：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("确保 "),s("code",[t._v("ON")]),t._v(" 和 "),s("code",[t._v("USING")]),t._v(" 字句中的列上有索引")]),t._v("。在创建索引的时候就要考虑到关联的顺序。当表 A 和表 B 用某列 column 关联的时候，如果优化器关联的顺序是 A、B，那么就不需要在 A 表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的第二张表的相应列上创建索引（具体原因下文分析）。")]),t._v(" "),s("li",[s("strong",[t._v("确保任何的 "),s("code",[t._v("GROUP BY")]),t._v(" 和 "),s("code",[t._v("ORDER BY")]),t._v(" 中的表达式只涉及到一个表中的列")]),t._v("，这样 MySQL 才有可能使用索引来优化。")])]),t._v(" "),s("p",[t._v("要理解优化关联查询的第一个技巧，就需要理解 MySQL 是如何执行关联查询的。当前 MySQL 关联执行的策略非常简单，它对任何的关联都执行"),s("strong",[t._v("嵌套循环关联")]),t._v("操作，即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。")]),t._v(" "),s("p",[t._v("太抽象了？以上面的示例来说明，比如有这样的一个查询：")]),t._v(" "),s("div",{staticClass:"language-css extra-class"},[s("pre",{pre:!0,attrs:{class:"language-css"}},[s("code",[t._v("SELECT A.xx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("B.yy\nFROM A INNER JOIN B "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("USING")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nWHERE A.xx IN "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("5"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("6"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("假设 MySQL 按照查询中的关联顺序 A、B 来进行关联操作，那么可以用下面的伪代码表示 MySQL 如何完成这个查询：")]),t._v(" "),s("div",{staticClass:"language-ruby extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ruby"}},[s("code",[t._v("outer_iterator "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("xx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FROM")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("WHERE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("xx "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("IN")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nouter_row "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" outer_iterator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("outer_row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    inner_iterator "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("yy "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FROM")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("WHERE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" outer_row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    inner_row "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" inner_iterator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("inner_row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        output"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("inner_row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("yy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("outer_row"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("xx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        inner_row "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" inner_iterator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    outer_row "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" outer_iterator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("可以看到，最外层的查询是根据"),s("code",[t._v("A.xx")]),t._v("列来查询的，"),s("code",[t._v("A.c")]),t._v("上如果有索引的话，整个关联查询也不会使用。再看内层的查询，很明显"),s("code",[t._v("B.c")]),t._v("上如果有索引的话，能够加速查询，因此只需要在关联顺序中的第二张表的相应列上创建索引即可。")]),t._v(" "),s("h3",{attrs:{id:"_2-3-优化-group-by-和-distinct"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-优化-group-by-和-distinct"}},[t._v("#")]),t._v(" 2.3. 优化 "),s("code",[t._v("GROUP BY")]),t._v(" 和 "),s("code",[t._v("DISTINCT")])]),t._v(" "),s("p",[t._v("Mysql 优化器会在内部处理的时候相互转化这两类查询。它们都"),s("strong",[t._v("可以使用索引来优化，这也是最有效的优化方法")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_2-4-优化-limit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-优化-limit"}},[t._v("#")]),t._v(" 2.4. 优化 "),s("code",[t._v("LIMIT")])]),t._v(" "),s("p",[t._v("当需要分页操作时，通常会使用 "),s("code",[t._v("LIMIT")]),t._v(" 加上偏移量的办法实现，同时加上合适的 "),s("code",[t._v("ORDER BY")]),t._v(" 字句。"),s("strong",[t._v("如果有对应的索引，通常效率会不错，否则，MySQL 需要做大量的文件排序操作")]),t._v("。")]),t._v(" "),s("p",[t._v("一个常见的问题是当偏移量非常大的时候，比如："),s("code",[t._v("LIMIT 10000 20")]),t._v("这样的查询，MySQL 需要查询 10020 条记录然后只返回 20 条记录，前面的 10000 条都将被抛弃，这样的代价非常高。")]),t._v(" "),s("p",[t._v("优化这种查询一个最简单的办法就是尽可能的使用覆盖索引扫描，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" film_id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("description "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" film "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" title "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LIMIT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("50")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("如果这张表非常大，那么这个查询最好改成下面的样子：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" film"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("film_id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("film"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("description\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" film "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INNER")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" film_id "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" film "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" title "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LIMIT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("50")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" tmp "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("USING")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("film_id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("这里的延迟关联将大大提升查询效率，让 MySQL 扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。")]),t._v(" "),s("p",[t._v("有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用"),s("code",[t._v("OFFSET")]),t._v("，比如下面的查询：")]),t._v(" "),s("div",{staticClass:"language-objectivec extra-class"},[s("pre",{pre:!0,attrs:{class:"language-objectivec"}},[s("code",[t._v("SELECT id FROM t LIMIT "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n改为：\nSELECT id FROM t WHERE id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000")]),t._v(" LIMIT "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("其他优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。")]),t._v(" "),s("h3",{attrs:{id:"_2-5-优化-union"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-优化-union"}},[t._v("#")]),t._v(" 2.5. 优化 UNION")]),t._v(" "),s("p",[t._v("MySQL 总是通过创建并填充临时表的方式来执行 "),s("code",[t._v("UNION")]),t._v(" 查询。因此很多优化策略在"),s("code",[t._v("UNION")]),t._v("查询中都没有办法很好的时候。经常需要手动将"),s("code",[t._v("WHERE")]),t._v("、"),s("code",[t._v("LIMIT")]),t._v("、"),s("code",[t._v("ORDER BY")]),t._v("等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。")]),t._v(" "),s("p",[t._v("除非确实需要服务器去重，否则就一定要使用"),s("code",[t._v("UNION ALL")]),t._v("，如果没有"),s("code",[t._v("ALL")]),t._v("关键字，MySQL 会给临时表加上"),s("code",[t._v("DISTINCT")]),t._v("选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用 ALL 关键字，MySQL 总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。")]),t._v(" "),s("h3",{attrs:{id:"_2-6-优化查询方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-优化查询方式"}},[t._v("#")]),t._v(" 2.6. 优化查询方式")]),t._v(" "),s("h4",{attrs:{id:"切分大查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#切分大查询"}},[t._v("#")]),t._v(" 切分大查询")]),t._v(" "),s("p",[t._v("一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[t._v("DELEFT "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" messages "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("create")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" DATE_SUB"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("NOW")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INTERVAL")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("MONTH")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[t._v("rows_affected "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" {\n    rows_affected "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" do_query"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"DELETE FROM messages WHERE create  < DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n} "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" rows_affected "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n")])])]),s("h4",{attrs:{id:"分解大连接查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分解大连接查询"}},[t._v("#")]),t._v(" 分解大连接查询")]),t._v(" "),s("p",[t._v("将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中进行关联，这样做的好处有：")]),t._v(" "),s("ul",[s("li",[t._v("让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。")]),t._v(" "),s("li",[t._v("分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。")]),t._v(" "),s("li",[t._v("减少锁竞争；")]),t._v(" "),s("li",[t._v("在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。")]),t._v(" "),s("li",[t._v("查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。")])]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" tag\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" tag_post "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ON")]),t._v(" tag_post"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("tag_id"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("tag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" post "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ON")]),t._v(" tag_post"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("post_id"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("post"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" tag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("tag"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'mysql'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" tag "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" tag"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'mysql'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" tag_post "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" tag_id"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1234")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" post "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" post"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("456")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("567")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9098")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8904")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"_3-执行计划-explain"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-执行计划-explain"}},[t._v("#")]),t._v(" 3. 执行计划（"),s("code",[t._v("EXPLAIN")]),t._v("）")]),t._v(" "),s("p",[t._v("如何判断当前 SQL 是否使用了索引？如何检验修改后的 SQL 确实有优化效果？")]),t._v(" "),s("p",[t._v("在 SQL 中，可以通过执行计划（"),s("code",[t._v("EXPLAIN")]),t._v("）分析 "),s("code",[t._v("SELECT")]),t._v(" 查询效率。")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[t._v("mysql"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("explain")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" user_info "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\\G\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("row")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n           id: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n  select_type: "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SIMPLE")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(": user_info\n   partitions: "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),t._v("\n         "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(": const\npossible_keys: "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PRIMARY")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("key")]),t._v(": "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PRIMARY")]),t._v("\n      key_len: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v("\n          ref: const\n         "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("rows")]),t._v(": "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n     filtered: "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100.00")]),t._v("\n        Extra: "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("row")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" warning "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.00")]),t._v(" sec"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[s("code",[t._v("EXPLAIN")]),t._v(" 参数说明：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("id")]),t._v(": SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.")]),t._v(" "),s("li",[s("code",[t._v("select_type")]),t._v(" ⭐ ：SELECT 查询的类型.\n"),s("ul",[s("li",[s("code",[t._v("SIMPLE")]),t._v("：表示此查询不包含 UNION 查询或子查询")]),t._v(" "),s("li",[s("code",[t._v("PRIMARY")]),t._v("：表示此查询是最外层的查询")]),t._v(" "),s("li",[s("code",[t._v("UNION")]),t._v("：表示此查询是 UNION 的第二或随后的查询")]),t._v(" "),s("li",[s("code",[t._v("DEPENDENT UNION")]),t._v("：UNION 中的第二个或后面的查询语句, 取决于外面的查询")]),t._v(" "),s("li",[s("code",[t._v("UNION RESULT")]),t._v("：UNION 的结果")]),t._v(" "),s("li",[s("code",[t._v("SUBQUERY")]),t._v("：子查询中的第一个 SELECT")]),t._v(" "),s("li",[s("code",[t._v("DEPENDENT SUBQUERY")]),t._v(": 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.")])])]),t._v(" "),s("li",[s("code",[t._v("table")]),t._v(": 查询的是哪个表，如果给表起别名了，则显示别名。")]),t._v(" "),s("li",[s("code",[t._v("partitions")]),t._v("：匹配的分区")]),t._v(" "),s("li",[s("code",[t._v("type")]),t._v(" ⭐：表示从表中查询到行所执行的方式，查询方式是 SQL 优化中一个很重要的指标，结果值从好到差依次是：system > const > eq_ref > ref > range > index > ALL。\n"),s("ul",[s("li",[s("code",[t._v("system")]),t._v("/"),s("code",[t._v("const")]),t._v("：表中只有一行数据匹配，此时根据索引查询一次就能找到对应的数据。如果是 B + 树索引，我们知道此时索引构造成了多个层级的树，当查询的索引在树的底层时，查询效率就越低。const 表示此时索引在第一层，只需访问一层便能得到数据。")]),t._v(" "),s("li",[s("code",[t._v("eq_ref")]),t._v("：使用唯一索引扫描，常见于多表连接中使用主键和唯一索引作为关联条件。")]),t._v(" "),s("li",[s("code",[t._v("ref")]),t._v("：非唯一索引扫描，还可见于唯一索引最左原则匹配扫描。")]),t._v(" "),s("li",[s("code",[t._v("range")]),t._v("：索引范围扫描，比如，<，>，between 等操作。")]),t._v(" "),s("li",[s("code",[t._v("index")]),t._v("：索引全表扫描，此时遍历整个索引树。")]),t._v(" "),s("li",[s("code",[t._v("ALL")]),t._v("：表示全表扫描，需要遍历全表来找到对应的行。")])])]),t._v(" "),s("li",[s("code",[t._v("possible_keys")]),t._v("：此次查询中可能选用的索引。")]),t._v(" "),s("li",[s("code",[t._v("key")]),t._v(" ⭐：此次查询中实际使用的索引。")]),t._v(" "),s("li",[s("code",[t._v("ref")]),t._v("：哪个字段或常数与 key 一起被使用。")]),t._v(" "),s("li",[s("code",[t._v("rows")]),t._v(" ⭐：显示此查询一共扫描了多少行，这个是一个估计值。")]),t._v(" "),s("li",[s("code",[t._v("filtered")]),t._v("：表示此查询条件所过滤的数据的百分比。")]),t._v(" "),s("li",[s("code",[t._v("extra")]),t._v("：额外的信息。")])]),t._v(" "),s("blockquote",[s("p",[t._v("更多内容请参考："),s("a",{attrs:{href:"https://segmentfault.com/a/1190000008131735",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL 性能优化神器 Explain 使用分析"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"_4-optimizer-trace"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-optimizer-trace"}},[t._v("#")]),t._v(" 4. optimizer trace")]),t._v(" "),s("p",[t._v("在 MySQL 5.6 及之后的版本中，我们可以使用 optimizer trace 功能查看优化器生成执行计划的整个过程。有了这个功能，我们不仅可以了解优化器的选择过程，更可以了解每一个执行环节的成本，然后依靠这些信息进一步优化查询。")]),t._v(" "),s("p",[t._v("如下代码所示，打开 optimizer_trace 后，再执行 SQL 就可以查询 information_schema.OPTIMIZER_TRACE 表查看执行计划了，最后可以关闭 optimizer_trace 功能：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" optimizer_trace"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"enabled=on"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" person "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" NAME "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'name84059'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" create_time"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("'"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2020")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("01")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("24")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("05")]),t._v(":"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("00")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" information_schema"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("OPTIMIZER_TRACE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" optimizer_trace"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"enabled=off"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"_5-数据模型和业务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-数据模型和业务"}},[t._v("#")]),t._v(" 5. 数据模型和业务")]),t._v(" "),s("ul",[s("li",[t._v("表字段比较复杂、易变动、结构难以统一的情况下，可以考虑使用 Nosql 来代替关系数据库表存储，如 ElasticSearch、MongoDB。")]),t._v(" "),s("li",[t._v("在高并发情况下的查询操作，可以使用缓存（如 Redis）代替数据库操作，提高并发性能。")]),t._v(" "),s("li",[t._v("数据量增长较快的表，需要考虑水平分表或分库，避免单表操作的性能瓶颈。")]),t._v(" "),s("li",[t._v("除此之外，我们应该通过一些优化，尽量避免比较复杂的 JOIN 查询操作，例如冗余一些字段，减少 JOIN 查询；创建一些中间表，减少 JOIN 查询。")])]),t._v(" "),s("h2",{attrs:{id:"_6-参考资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-参考资料"}},[t._v("#")]),t._v(" 6. 参考资料")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://book.douban.com/subject/23008813/",target:"_blank",rel:"noopener noreferrer"}},[t._v("《高性能 MySQL》"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://time.geekbang.org/column/intro/100028001",target:"_blank",rel:"noopener noreferrer"}},[t._v("《Java 性能调优实战》"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://www.jianshu.com/p/d7665192aaaf",target:"_blank",rel:"noopener noreferrer"}},[t._v("我必须得告诉大家的 MySQL 优化原理"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("20+ 条 MySQL 性能优化的最佳经验"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://segmentfault.com/a/1190000008131735",target:"_blank",rel:"noopener noreferrer"}},[t._v("MySQL 性能优化神器 Explain 使用分析"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=e.exports}}]);